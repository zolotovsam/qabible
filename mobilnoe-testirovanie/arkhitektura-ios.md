# Архитектура iOS

Все в курсе, что мобильные девайсы Apple работают под управлением iOS. Многие знают, что iOS представляет собой облегченную версию настольной Mac OS X. Некоторые догадываются, что в основе Mac OS X лежит POSIX-совместимая ОС Darwin, а те, кто всерьез интересуется IT, в курсе, что основа Darwin - это ядро XNU, появившееся на свет в результате слияния микроядра Mach и компонентов ядра FreeBSD. Однако все это голые факты, которые ничего не скажут нам о том, как же на самом деле работает iOS и в чем ее отличия от настольного собрата.

**Mac OS X**

Операционная система, установленная сегодня на все маки и (в измененном виде) на айдевайсы, ведет свою историю аж с 1988 года, который в мире IT известен также тем, что стал годом выпуска первой бета-версии операционной системы NeXTSTEP. Сама NeXTSTEP была детищем команды разработчиков Стива Джобса, который к тому времени уже покинул Apple и основал компанию NeXT, которая занялась разработкой компьютеров для образовательных нужд.

В момент своего появления на свет NeXTSTEP была поистине передовой операционной системой, которая включала в себя множество технологических новаций. В основе ОС лежало модифицированное микроядро Mach, дополненное компонентами ядра FreeBSD, включая эталонную реализацию сетевого стека. Более высокоуровневые компоненты NeXTSTEP были написаны с использованием языка Objective-C и предоставляли разработчикам приложений богатый объектно-ориентированный API. Система была снабжена развитым и весьма удобным графическим интерфейсом (ключевые компоненты которого сохранились в OS X и даже iOS) и мощной средой разработки, включавшей в себя в том числе известный всем современным разработчикам визуальный дизайнер интерфейса.

После провала NeXT и возвращения Стива Джобса в компанию Apple в 1997 году NeXTSTEP легла в основу проекта Rhapsody, в рамках которого началась разработка системы-наследника Mac OS 9. В 2000 году из Rhapsody был выделен открытый проект Darwin, исходники которого опубликованы под лицензией APSL, а уже в 2001 году появилась на свет OS X 10.0, построенная на его основе. Спустя несколько лет Darwin лег в основу операционной системы для готовящегося к выпуску смартфона, о котором до 2007-го, кроме слухов, не было известно почти ничего.

**XNU и Darwin**

Условно начинку OS X / iOS можно разделить на три логических уровня: ядро XNU, слой совместимости со стандартом POSIX (плюс различные системные демоны/сервисы) и слой NeXTSTEP, реализующий графический стек, фреймворк и API приложений. Darwin включает в себя первые два слоя и распространяется свободно, но только в версии для OS X. iOS-вариант, портированный на архитектуру ARM и включающий в себя некоторые доработки, полностью закрыт и распространяется только в составе прошивок для айдевайсов (судя по всему, это защита от портирования iOS на другие устройства).

По своей сути Darwin - это «голая» UNIX-подобная ОС, которая включает в себя POSIX API, шелл, набор команд и сервисов, минимально необходимых для работы системы в консольном режиме и запуска UNIX-софта. В этом плане он похож на базовую систему FreeBSD или минимальную установку какого-нибудь Arch Linux, которые позволяют запустить консольный UNIX-софт, но не имеют ни графической оболочки, ни всего необходимого для запуска серьезных графических приложений из сред GNOME или KDE.

Ключевой компонент Darwin - гибридное ядро XNU, основанное, как уже было сказано выше, на ядре Mach и компонентах ядра FreeBSD, таких как планировщик процессов, сетевой стек и виртуальная файловая система (слой VFS). В отличие от Mach и FreeBSD, ядро OS X использует собственный API драйверов, названный I/O Kit и позволяющий писать драйверы на C++, используя объектно-ориентированный подход, сильно упрощающий разработку.

iOS использует несколько измененную версию XNU, однако в силу того, что ядро iOS закрыто, сказать, что именно изменила Apple, затруднительно. Известно только, что оно собрано с другими опциями компилятора и модифицированным менеджером памяти, который учитывает небольшие объемы оперативки в мобильных устройствах. Во всем остальном это все то же XNU, которое можно найти в виде зашифрованного кеша (ядро + все драйверы/модули) в каталоге /System/Library/Caches/com.apple.kernelcaches/kernelcache на самом устройстве.

Уровнем выше ядра в Darwin располагается слой UNIX/BSD, включающий в себя набор стандартных библиотек языка си (libc, libmatch, libpthread и так далее), а также инструменты командной строки, набор шеллов (bash, tcsh и ksh) и демонов, таких как launchd и стандартный SSH-сервер. Последний, кстати, можно активировать путем правки файла /System/Library/LaunchDaemons/ssh.plist. Если, конечно, джейлбрейкнуть девайс.

На этом открытая часть ОС под названием Darwin заканчивается, и начинается слой фреймворков, которые как раз и образуют то, что мы привыкли считать OS X / iOS.

**Фреймворки**

Darwin реализует лишь базовую часть Mac OS / iOS, которая отвечает только за низкоуровневые функции (драйверы, запуск/остановка системы, управление сетью, изоляция приложений и так далее). Та часть системы, которая видна пользователю и приложениям, в его состав не входит и реализована в так называемых фреймворках - наборах библиотек и сервисов, которые отвечают в том числе за формирование графического окружения и высокоуровневый API для сторонних и стоковых приложений

Как и во многих других ОС, API Mac OS и iOS разделен на публичный и приватный. Сторонним приложениям доступен исключительно публичный и сильно урезанный API, однако jailbreak-приложения могут использовать и приватный.

В стандартной поставке Mac OS и iOS можно найти десятки различных фреймворков, которые отвечают за доступ к самым разным функциям ОС - от реализации адресной книги (фреймворк AddressBook) до библиотеки OpenGL (GLKit). Набор базовых фреймворков для разработки графических приложений объединен в так называемый Cocoa API, своего рода метафреймворк, позволяющий получить доступ к основным возможностям ОС. В iOS он носит имя Cocoa Touch и отличается от настольной версии ориентацией на сенсорные дисплеи.

Далеко не все фреймворки доступны в обеих ОС. Многие из них специфичны только для iOS. В качестве примеров можно привести AssetsLibrary, который отвечает за работу с фотографиями и видео, CoreBlueTooth, позволяющий получить доступ к синезубу, или iAd, предназначенный для вывода рекламных объявлений в приложениях. Другие фреймворки существуют только в настольной версии системы, однако время от времени Apple переносит те или иные части iOS в Mac OS или обратно, как, например, случилось с фреймворком CoreMedia, который изначально был доступен только в iOS.

Все стандартные системные фреймворки можно найти в системном каталоге /System/Library/Frameworks/. Каждый из них находится в своем собственном каталоге, называемом бандлом (boundle), который включает в себя ресурсы (изображения и описание элементов интерфейса), хидеры языка си, описывающие API, а также динамически загружаемую библиотеку (в формате dylib) с реализацией фреймворка.

Одна из интересных особенностей фреймворков - их версионность. Один фреймворк может иметь сразу несколько разных версий, поэтому приложение, разработанное для устаревших версий системы, будет продолжать работать, даже несмотря на изменения, внесенные в новые версии ОС. Именно так реализован механизм запуска старых iOS-приложений в iOS 7 и выше. Приложение, разработанное для iOS 6, будет выглядеть и работать именно так, как если бы оно было запущено в iOS 6.

**SpringBoard**

Уровнем выше находятся приложения, системные и устанавливаемые из магазина приложений. Центральное место среди них занимает, конечно же, SpringBoard (только в iOS), реализующее домашний экран (рабочий стол). Именно оно запускается первым после старта системных демонов, загрузки в память фреймворков и старта дисплейного сервера (он же менеджер композитинга, он же Quartz Compositor), отвечающего за вывод изображения на экран.

SpringBoard - это связующее звено между операционной системой и ее пользователем, графический интерфейс, позволяющий запускать приложения, переключаться между ними, просматривать уведомления и управлять некоторыми настройками системы (начиная с iOS 7). Но также это и обработчик событий, таких как касание экрана или переворот устройства. В отличие от Mac OS X, которая использует различные приложения и демоны-агенты для реализации компонентов интерфейса (Finder, Dashboard, LaunchPad и другие), в iOS почти все базовые возможности интерфейса пользователя, в том числе экран блокировки и «шторка», заключены в одном SpringBoard.

В отличие от других стоковых приложений iOS, которые располагаются в каталоге /Applications, SpringBoard наравне с дисплейным сервером считается частью фреймворков и располагается в каталоге /System/Library/CoreServices/. Для выполнения многих задач он использует плагины, которые лежат в /System/Library/SpringBoardPlugins/. Кроме всего прочего, там можно найти, например, NowPlayingArtLockScreen.lockboundle, отвечающий за отображение информации о проигрываемой композиции на экране блокировки, или IncomingCall.serviceboundle, ответственный за обработку входящего звонка.

Начиная с iOS 6 SpringBoard разделен на две части: сам рабочий стол и сервис BackBoard, ответственный за коммуникации с низкоуровневой частью ОС, работающей с оборудованием (уровень HAL). BackBoard отвечает за обработку таких событий, как касания экрана, нажатия клавиш, получение показания акселерометра, датчика положения и датчика освещенности, а также управляет запуском, приостановкой и завершением приложений.

SpringBoard и BackBoard имеют настолько большое значение для iOS, что, если каким-либо образом их остановить, вся система застынет на месте и даже запущенное в данный момент приложение не будет реагировать на касания экрана. Это отличает их от домашнего экрана Android, который является всего лишь стандартным приложением, которое можно остановить, заменить или вообще удалить из системы (в этом случае на экране останутся вполне рабочие кнопки навигации и строка состояния со «шторкой»).

**Приложения**

На самой вершине этой пирамиды находятся приложения. iOS различает встроенные (стоковые) высоко привилегированные приложения и сторонние, устанавливаемые из iTunes. И те и другие хранятся в системе в виде бандлов, во многом похожих на те, что используются для фреймворков. Разница заключается лишь в том, что бандл приложения включает в себя несколько иную метаинформацию, а место динамической библиотеки занимает исполняемый файл в формате Mach-O.

Стандартный каталог хранения стоковых приложений - /Applications/. В iOS он абсолютно статичный и изменяется только во время обновлений системы; пользователь получить к нему доступ не может. Сторонние приложения, устанавливаемые из iTunes, напротив, хранятся в домашнем каталоге пользователя /var/mobile/Applications/ внутри подкаталогов, имеющих вид 4-2-2-2-4, где два и четыре - это шестнадцатеричные числа. Это так называемый GUID - уникальный идентификатор, который однозначно идентифицирует приложение в системе и нужен в том числе для создания изолированной песочницы (sandbox).

**Sandbox**

В iOS песочницы используются для изолирования сервисов и приложений от системы и друг от друга. Каждое стороннее приложение и большинство системных работают в песочнице. С технической точки зрения песочница представляет собой классический для мира UNIX chroot, усиленный системой принудительного контроля доступа TrustedBSD MAC (модуль ядра sandbox.kext), которая отрезает приложениям не только доступ к файлам за пределами домашнего каталога, но и прямой доступ к железу и многим системным функциям ОС.

В целом заключенное в sandbox приложение ограничено в следующих возможностях:

* Доступ к файловой системе за исключением своего собственного каталога и домашнего каталога пользователя.
* Доступ к каталогам Media и Library внутри домашнего каталога за исключением Media/DCIM/, Media/Photos/, Library/AddressBook/, Library/Keyboard/ и Library/Preferences/.
* Доступ к информации о других процессах (приложение «считает» себя единственным в системе).
* Прямой доступ к железу (разрешено использовать только Cocoa API и другие фреймворки).
* Ограничение на использование оперативной памяти (контролируется механизмом Jatsam).

Все эти ограничения соответствуют sandbox-профилю (набору ограничивающих правил) container и применяются к любому стороннему приложению. Для стоковых приложений, в свою очередь, могут применяться другие ограничения, более мягкие или жесткие. В качестве примера можно привести почтовый клиент (профиль MobileMail), который в целом имеет такие же серьезные ограничения, как и сторонние приложения, но может получить доступ ко всему содержимому каталога Library/. Обратная ситуация - SpringBoard, вообще не имеющий ограничений.

Внутри песочниц работают многие системные демоны, включая, например, AFC, предназначенный для работы с файловой системой устройства с ПК, но ограничивающий «область видимости» только домашним каталогом пользователя. Все доступные системные sandbox-профили располагаются в каталоге /System/Library/Sandbox/Profiles/\* и представляют собой наборы правил, написанных на языке Scheme. Кроме этого, приложения также могут включать в себя дополнительные наборы правил, называемых entitlement. По сути, это все те же профили, но вшитые прямо в бинарный файл приложения (своего рода самоограничение).

Смысл существования всех этих ограничений двойной. Первая (и главная) задача, которую решает sandbox, - это защита от вредоносных приложений. Вкупе с тщательной проверкой опубликованных в iTunes приложений и запретом на запуск не подписанных цифровым ключом приложений (читай: любых, полученных не из iTunes) такой подход дает прекрасный результат и позволяет iOS находиться на вершине в списке самых защищенных от вирусов ОС.

Вторая проблема - это защита системы от самой себя и пользователя. Баги могут существовать как в стоковом софте от Apple, так и в головах юзеров. Sandbox защищает от обоих. Даже если злоумышленник найдет дыру в Safari и попытается ее эксплуатировать, он все равно останется в песочнице и не сможет навредить системе. А юзер не сможет «сломать свой любимый телефончик» и не напишет гневных отзывов в адрес Apple. К счастью, знающие люди всегда могут сделать jailbreak и обойти защиту sandbox (собственно, в этом и есть смысл джейлбрейка).

**Многозадачность**

Одна из самых спорных особенностей iOS - это реализация многозадачности. Она вроде бы и есть, а с другой стороны, ее нет. В сравнении с традиционными настольными ОС и пресловутым Android iOS не является многозадачной операционной системой в привычном смысле этого слова и не позволяет приложениям свободно работать в фоне. Вместо этого ОС реализует API, который приложение может использовать для выполнения отдельных задач, пока оно находится в фоновом режиме.

Впервые такой API появился в iOS 4 (до этого фоновые задачи могли выполнять только стоковые приложения) и наращивался по мере развития операционной системы. Сегодня (речь идет об iOS 7) так называемый Background API позволяет делать следующее:

* проигрывать аудио;
* совершать VoIP-звонки;
* получать информацию о смене местоположения;
* получать push-уведомления;
* планировать отложенный вывод уведомлений;
* запрашивать дополнительное время для завершения работы после перехода в фоновый режим;
* обмениваться данными с подключенными к девайсу аксессуарами (в том числе Bluetooth);
* получать и отправлять данные по сети (начиная с iOS 7).

Такие ограничения на работу в фоне необходимы в первую очередь для того, чтобы сохранить заряд батареи и избежать лагов интерфейса, так знакомых пользователям Android, где приложения могут делать в фоне все что захотят. На самом деле Apple настолько сильно заботится о сохранении батареи, что даже реализовала специальный механизм для группировки фоновых действий приложений и их запуска в нужные моменты, например тогда, когда смартфон активно используется, подключен к Wi-Fi-сети или к зарядному устройству.

**Шесть стадий загрузки iOS**

![https://xakep.ru/wp-content/uploads/2015/02/boot\_KakustroenaiOS.png](https://xakep.ru/wp-content/uploads/2015/02/boot\_KakustroenaiOS.png)

* Boot ROM. После включения устройства первым запускается минималистичный загрузчик, прошитый в постоянную память устройства. Его задача - произвести начальную инициализацию железа и передать управление первичному загрузчику LLB. Boot ROM всегда имеет заводскую прошивку и не может быть обновлен.
* Low Level Bootloader (LLB). Далее управление получает LLB. Это первичный загрузчик, задача которого - найти в памяти устройства iBoot, проверить его целостность и передать ему управление либо переключить девайс в режим восстановления, если это не удалось. Код LLB хранится в NAND-памяти устройства и обновляется вместе с установкой новой версии прошивки. Кроме всего прочего, он выводит на экран загрузочный логотип.
* iBoot. Это вторичный и основной загрузчик айдевайсов. Он включает в себя драйвер файловой системы, с помощью которого получает доступ к содержимому NAND-памяти, находит ядро и передает ему управление. В iBoot также встроен драйвер UART, с помощью которого можно производить отладку ядра и ОС, подключив девайс к COM-порту или USB-порту компа (с помощью кабеля USB - UART).
* Ядро. Здесь все как обычно. Ядро производит инициализацию оборудования, после чего передает управление демону launchd.
* Launchd. Это первичный процесс iOS и Mac OS X, он подключает файловые системы, запускает демоны/службы (например, backupd, configd, locationd), дисплейный сервер, фреймворки, а на последнем этапе загрузки отдает управление SpringBoard. В iOS и Mac OS X launchd используется как замена стандартного /bin/init в UNIX, однако его функциональность гораздо шире.
* SpringBoard. Вот и экран блокировки!

Первые четыре этапа в этой цепи образуют chain of trust, реализованный с помощью сверки цифровой подписи загружаемого компонента. Цифровую подпись имеют LLB, iBoot и ядро, что позволяет исключить внедрение в цепочку хакнутого загрузчика или ядра, которые могут быть использованы для загрузки сторонней операционной системы или джейлбрейка. Единственный способ обойти этот механизм - найти дыру в одном из загрузчиков и воспользоваться ею для обхода проверки. В свое время было найдено несколько таких дыр в Boot ROM (наиболее известен эксплойт limera1n от geohot, актуальный для iPhone 1-4), а в начале 2014 года и в iBoot (хакер iH8sn0w, эксплойт так и не был опубликован).

Удерживая кнопку «Домой» при включении iPhone, можно заставить iBoot загрузиться в так называемый режим восстановления (Recovery), который позволяет восстановить прошивку iOS или обновить ее, используя iTunes. Однако механизм автоматического OTA-обновления использует другой режим, именуемый DFU (Device Firmware Upgrade), который активируется на раннем этапе загрузки сразу после Boot ROM и реализован в двух компонентах: iBSS и iBEC. По сути, это аналоги LLB и iBoot, конечная цель которых - не загрузить ОС, а перевести смартфон в режим обновления.

Источники:

* [Как устроена iOS](https://xakep.ru/2014/10/08/kau-ustroena-ios/)

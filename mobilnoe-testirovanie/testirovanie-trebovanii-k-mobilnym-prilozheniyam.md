# Тестирование требований к мобильным приложениям

Шпаргалка-чеклист для ревью ТЗ к мобильному приложению:

**Общие вопросы по приложению**

* Для каких платформ будет разрабатываться приложение и какие версии ОС будут поддерживаться? Необходимо всегда помнить о минимальной поддерживаемой версии ОС. Иначе можно обнаружить, что функциональность не работает у пользователей, когда задача уже закрыта.
* На каких устройствах необходимо проверить приложение? Например, приложение должно работать как на смартфонах, так и на планшетах. Или должна быть поддержка Apple Watch.
* Какую ориентацию экранов поддерживает приложение? Портретная и/или ландскейп? Неприятный момент: если смена ориентации экрана хорошо работает на смартфонах, это не значит, что всё будет так же на планшетах.
* На каких девайсах приоритетнее всего смотреть? На ваших девайсах приложение может идеально работать, а вот у заказчика на любимом (вставьте китайский android-смартфон) все разъехалось...
* Должен быть идеальный пиксель-перфект или допускаются некоторые погрешности? Привет, тестирование на соответствие макетам! Ещё неплохо уточнить, должна ли растягиваться вёрстка или под каждый размер экрана должны быть свои макеты?
* Существуют ли другие клиентские приложения? Например, есть админка, которая внезапно начнет удалять или добавлять элементы. Или веб-версия, которая существует уже в продакшене. Главное - узнать об этом как можно раньше.
* Есть ли какие-то внешние устройства, которые могут повлиять на логику мобильного приложения? Например, beacon'ы, отправляющие сигналы приложению, или принтеры, печатающие информацию из приложения.
* Какая целевая аудитория у приложения? Все пользователи в Play Market/AppStore или 50 человек в компании заказчика?

**Разбор приложения по экранам**

* Состав экрана и возможные действия на нем. Из каких элементов состоит экран? Какие действия можно совершить? Какие состояния экрана возможны? Какие есть переходы и на какие экраны они ведут? Что должно отображаться при возврате на этот экран? Ответы на эти вопросы необходимо найти, а лучше зафиксировать в документации.
* Взаимодействие с сервером на экране. Какие запросы идут на экране? Понимание того, какие запросы на сервер отправляются на экране, поможет выявить такие требования, которые не сможет реализовать сервер по тем или иным причинам.
* Активность по таймеру. Например, отправляется важная аналитика раз в две минуты или идет обновление данных.
* Кэширование данных. Загрузка одних и тех же данных при каждом входе на экран может раздражать пользователей. При кэшировании необходимо продумать, когда должна обновляться информация на экране? Когда должен очищаться кэш?
* Заглушки. Что отображается, если данных нет? Пустой экран - неинформативный для пользователя. А съехавшая заглушка может быть поводом для недовольства заказчика.
* Поведение в случаях ошибки. Что должно отображаться, если произошла ошибка? Например, отсутствие интернета, серверная или незадокументированная ошибка.
* Медленная загрузка данных. Что должно происходить при медленной загрузке данных? Лоадеры, блокировка действий, кастомные анимации - всё должно быть продумано.
* Действия, которые влияют на поведение других экранов. Как действие на одном экране повлияет на поведение на других? Сквозные действия - опасная штука. Особенно, если разработка и тестирование идет по экранам или по отдельным фичам. Тут без регрессии обойтись сложно. Поэтому на некоторых проектах, прежде чем писать тест-кейсы, мы строим матрицу влияния для новых фич.
* Обновление данных на экране. Когда происходит обновление? Есть следующие варианты и они могут сочетаться:
  * Каждый раз при открытии экрана (данные живут только пока у пользователя открыт экран).
  * Каждый раз при запуске приложения (данные живут только пока у пользователя запущено приложение).
  * По pull-to-refresh'у/по специальной кнопке обновления/по таймеру (данные хранятся в локальном хранилище устройства и при перезапуске приложения восстанавливаются).

Далее рассмотрим функциональность, которая часто используется в приложениях.

**Навигация в приложении**

* С помощью бокового меню. Какие разделы являются корневыми? Какие разделы открываются поверх корневых? Сбрасывается ли история переходов между корневыми разделами?
* С помощью таббара. Остаётся ли таббар на экране при углублении по навигации внутри раздела? Возвращает ли на корневой экран при повторном тапе на разделе?
* Различие в переходах между аппаратной и программной кнопкой «Back» в Android.

**Локализация**

Виды поддерживаемой локализации:

* Тексты зашиты внутри приложения. Пользователь в настройках приложения может выставить необходимый язык.
* Тексты зависят от языка в системных настройках. Язык определяется в зависимости от установленного языка в системных настройках.
* Тексты приходят с сервера. Тексты приходят с сервера, и язык зависит либо от настроек устройства, либо от настроек приложения.

**Разрешения**

* Запрос на доступ к нотификациям, геолокации, галерее, камере, смс… Кастомный экран или просто системный алерт?
* Пользователь отказался предоставить доступ. Как приложение поведет себя в этом случае? Предусмотрена ли логика перезапроса на доступ?
* Пользователь отключил в системных настройках доступ (см. пункт выше).

**Списки**

Часто мобильные приложения включают в себя списки. Для них стоит обратить внимание на следующие моменты:

* Первая загрузка списка. Сколько элементов загружаются за один раз? Что происходит при загрузке? Какое максимальное время может загружаться список?
* Наличие пэйджинга. Есть ли подгрузка элементов при скролле или весь список загружается за раз? Если есть подгрузка, то обязательно надо проверить, что элементы на границах не пропадают и не дублируются.
* Обновление списка (см. варианты выше).
* Наличие разделов.
* Наличие фильтров/сортировок. Фильтр может быть локальным или серверным. Для списков, которые загружаются целиком или зашиты внутри приложения, фильтры чаще всего локальные, и тестирование их не вызывает особых трудностей. Для списков с подгрузкой фильтры могут повлечь большое количество проверок. Аналогично для сортировок.
* Состав каждого элемента в списке. Тут может быть как элементарный текст, так и целые экраны со своей внутренней логикой.
* Взаимодействие с элементами. Добавление нового элемента, удаление, скрытие, перетаскивание.
* Синхронизация списка между всеми устройствами. В качестве примера можно привести синхронизацию файлов после его изменения на всех устройствах.
* Сохранение позиции скролла. При переходах между разделами или при возвращении на экран со списком может быть очень важной фичей. Например, если это лента постов.

Поиск по списку

* Онлайн/оффлайн поиск. С оффлайновым поиском всё просто. По сути, это локальный фильтр. Для онлайнового поиска, так же как и для онлайновых фильтров, кейсов будет гораздо больше.
* Посимвольный поиск или поиск по нажатию на кнопку поиска. Обратите внимание, для посимвольного поиска должно быть ограничение на количество запросов, иначе сервер может начать игнорировать спам от приложения.
* Очистка поисковой строки.
* Наличие подсказок.
* Наличие истории запросов.

**Форма ввода**

* Перечень полей с их описанием и особенностями.
* Условия сохранения и сброса данных в полях. Когда и какие поля должны сохранять свои значения? Когда очищаться?
* Ограничения на количество и вид символов.
* Клавиатура для ввода данных по выбранному полю. Вид клавиатуры: цифровая или символьная. Должна ли клавиатура сдвигать контент при открытии? При каких условиях она должна закрываться?
* Логика переходов между полями. По кнопке «Далее», по «Next» на клавиатуре.
* Валидация некорректно введенных данных. Проверки на сервере или на клиенте.
* Автозапросы на сервер при определенных условиях. Например, если пользователь ввел 6-значный код подтверждения.

**Учетные записи**

* Требования к регистрации и авторизации пользователей. Есть ли возможность регистрации не через мобильное приложение?
* Восстановление учетной записи. Например, если пользователь забыл пароль от приложения.
* Логаут. Очистка данных (в частности, сброс привязки пуш-нотификаций) для учетной записи.
* Авторизация по смс-коду. Должны учитываться кейсы с телефонным номером, его форматом, кодом возможных стран. Переотправка смс в случае проблем с получением.
* Авторизация через соцсети (см. подробности ниже в разделе «Регистрация/авторизация через соцсети»).
* Авторизация на нескольких устройствах одновременно. Автологаут или обработка синхронизации данных.
* Обработка ошибки неверного, устаревшего токена учетной записи.
* Изменение данных учетной записи. Например, смена пароля.

**Регистрация/авторизация через соцсети**

* Создание учетной записи при первой авторизации через соцсеть.
* Подгрузка данных из соцсети. Синхронизация при их изменении в соцсети. Например, имя-фамилия пользователя и аватарка.
* Авторизация через мобильное приложение, соцсети или браузер/вебвью.
* Запрет доступа приложению к данным из соцсети.

**Ролевая модель**

* Описание ролевой модели. Какие действия доступны для каждой роли?
* Взаимодействие между представителями разных ролей. Взаимодействие между представителями одной роли.
* Переход пользователей от одной роли к другой. Какие действия для этого должны выполниться?
* Предполагаемое процентное соотношение представителей разных ролей. На какую роль обратить внимание в первую очередь?

**Карта**

* Первая загрузка карты. Какая область должна загрузиться? Где и в каком масштабе должна быть отцентрирована карта?
* Загрузка и отрисовка элементов. Должны ли загруженные элементы кэшироваться? Когда элементы должны обновляться? Этот момент очень важно продумать, чтобы обеспечить быструю загрузку данных и плавные перемещения по карте.
* Логика работы элементов на карте. Пины, попапы над пинами, карточки для пинов, построение маршрута.
* Поддержка масштабирования, вращения, наклона карты.
* Обновление геопозиции и отправка координат текущего местоположения при свернутом приложении.

**Чаты**

* Обработка кейсов, если отправка сообщений была при отсутствии интернет-соединения или при плохом интернете. Повторная отправка сообщений.
* Групповые чаты. Логика добавления/удаления собеседников в чате. Максимальное количество собеседников.
* Статусы отправки/получения сообщений. Тут лучше сразу обратить внимание на групповые чаты. Что считается прочитанным сообщением в групповых чатах?
* Подгрузка истории чата (см. вопросы для списков).
* Наличие дополнительных фич: удаление сообщений, отображение «Пользователь Х печатает», превью отправляемых файлов, пересылки сообщений.
* Механизм работы чата. Например, необходимо понимать принцип работы чата на сокетах, чтобы во время тестирования локализовывать баги и определять, на чьей стороне проблема.

**Отправка файлов на сервер и скачивание на устройство**

* Формат файлов. Какие форматы файлов система должна обрабатывать и на какие выдавать ошибку?
* Возобновление прерванной отправки/скачивания. Автоматическое или после подтверждения пользователя?
* Максимальное количество отправляемых/закачиваемых файлов.
* Нехватка памяти на устройстве для скачивания файла. На практике были случаи, когда памяти не хватает, чтобы не просто скачать файл, а даже сделать запись в базу данных. Такие проблемы приходилось обрабатывать.
* Отмена отправки/скачивания файла.
* Замена файла один на другой.
* Скачивание на внешнюю память SD Card.
* Скачивание в фоне при свернутом приложении.

**Внешние устройства**

* Подключение/отключение устройства. Канал связи, по которому оно взаимодействует с приложением (Wi-Fi/Bluetooth).
* Влияние внешнего устройства на логику приложения.
* Конфигурация внешнего устройства. Есть ли какие-то системы, которые администрируют внешнее устройство?
* Максимальное расстояние, на котором происходит взаимодействие.
* Сила/мощность сигнала. Выясните, от чего могут зависеть эти параметры? Например, если beacon спрятать в металлическую банку, то шансы на потерю его сигнала резко возрастает.
* Подключение нескольких внешних устройств одновременно. Например, переключение с одного устройства на другое может привести к любопытным кейсам.
* Подключение к внешнему устройству при свернутом приложении/при заблокированном экране.

**Аудиоплеер/видеоплеер**

* Поддерживаемые форматы файлов.
* Кэширование проигрываемого контента. Обязательно нужно понять, какой объем данных необходимо кэшировать для удобства пользователя.
* Проигрывание в фоне. Нужна ли подгрузка данных при свернутом приложении?
* Нотификация плеера в системной шторке.
* Интеграция с Bluetooth-гарнитурой, CarPlay и с другими внешними системами.

**Оплата банковской картой**

* Привязка к профилю и удаление банковской карты. Есть ли тестовое снятие минимальной суммы? Например, 1 рубль, который потом вернется на счет.
* Оплата привязанной картой. Например, будет ли повторный запрос на смс-подтверждение при последующих оплатах?
* Обработка ошибок при попытке привязать/оплатить по карте.
* Синхронизация списка карт при наличии нескольких клиентов в системе. Например, есть веб-версия и есть iOS-версия.
* Сканирование через камеру и распознавание номера карты.

**Время, календарь, таймер**

* Календарь/время. Влияет ли на логику приложения некорректно выставленная дата и время? Можно ли выбрать период? Какая область допустимых значений?
* Таймер. Локальный/серверный? Как происходит синхронизация серверного таймера? Например, в Android приложение может ориентироваться не на время, установленное на устройстве, а на время запуска устройства. Как бы пользователь не переводил часы в системных настройках, таймер не собьется.

**Нотификации**

* Вид нотификаций. Есть ли нотификации на определенные события, которые зашиты в приложение? Или push-нотификации, которые присылает сервер?
* Действия, которые доступны при нотификации. Что будет, если перейти по нотификации? Закрыть её? Что если нотификация устарела и она недоступна?
* Привязка нотификаций к определенной учетке. Какие действия указывают серверу, что один пользователь вышел и зашел другой?

Источники:

* [Шпаргалка по тестированию требований к мобильным приложениям](https://habr.com/ru/company/mobileup/blog/336992/)

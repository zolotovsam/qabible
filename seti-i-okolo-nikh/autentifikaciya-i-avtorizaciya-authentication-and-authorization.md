# Аутентификация и авторизация (Authentication and authorization)

**Идентификация** - процедура, в результате выполнения которой для субъекта идентификации выявляется его идентификатор, однозначно определяющий этого субъекта в информационной системе.

**Аутентификация** - процедура проверки подлинности, например проверка подлинности пользователя путем сравнения введенного им пароля с паролем, сохраненным в базе данных.

**Авторизация** - предоставление определенному лицу или группе лиц прав на выполнение определенных действий.

_В англоязычных источниках идентификация не выделяется в отдельный пункт: “Authentication is the process of **identifying** users and **validating** who they claim to be”._

Скажем, пользователь хочет войти в свой аккаунт Google. Google подходит лучше всего, потому что там процедура входа явным образом разбита на несколько простейших этапов. Вот что при этом происходит:

* Для начала система запрашивает логин, пользователь его указывает, система распознает его как существующий - это идентификация.
* После этого Google просит ввести пароль, пользователь его вводит, и система соглашается, что пользователь, похоже, действительно настоящий, раз пароль совпал, - это аутентификация.
* Скорее всего, Google дополнительно спросит еще и одноразовый код из SMS или приложения. Если пользователь и его правильно введет, то система окончательно согласится с тем, что он настоящий владелец аккаунта, - это двухфакторная аутентификация.
* После этого система предоставит пользователю право читать письма в его почтовом ящике и все в таком духе - это авторизация.

Аутентификация без предварительной идентификации лишена смысла - пока система не поймет, подлинность чего же надо проверять, совершенно бессмысленно начинать проверку. Для начала надо представиться.

Идентификация без аутентификации - это просто глупо. Потому что мало ли кто ввел существующий в системе логин! Системе обязательно надо удостовериться, что этот кто-то знает еще и пароль. Но пароль могли подсмотреть или подобрать, поэтому лучше подстраховаться и спросить что-то дополнительное, что может быть известно только данному пользователю: например, одноразовый код для подтверждения входа.

А вот авторизация без идентификации и тем более аутентификации очень даже возможна. Например, в Google Документах можно публиковать документы так, чтобы они были доступны вообще кому угодно. В этом случае вы как владелец файла увидите сверху надпись, гласящую, что его читает неопознанный енот. Несмотря на то, что енот совершенно неопознанный, система его все же авторизовала - то есть выдала право прочитать этот документ.

А вот если бы вы открыли этот документ для чтения только определенным пользователям, то еноту в таком случае сперва пришлось бы идентифицироваться (ввести свой логин), потом аутентифицироваться (ввести пароль и одноразовый код) и только потом получить право на чтение документа - авторизоваться.

**Фреймворк HTTP-аутентификации** (HTTP authentication framework)

[RFC 7235](https://datatracker.ietf.org/doc/html/rfc7235) определяет HTTP authentication framework, который может использоваться сервером для вызова клиентского запроса (to [challenge](https://developer.mozilla.org/en-US/docs/Glossary/challenge) a client request) и клиентом для предоставления информации для проверки подлинности. Порядок вызовов и ответов:

* Сервер отвечает клиенту со статусом ответа 401 (Unauthorized) и предоставляет информацию о том, как авторизоваться, с WWW-Authenticate response header, содержащим как минимум один вызов.
* Клиент, который хочет аутентифицировать себя на сервере, может сделать это, включив Authorization request header с учетными данными (credentials).
* Обычно клиент представляет пользователю запрос пароля, а затем отправляет запрос, включая правильный Authorization header.

![https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication/http-auth-sequence-diagram.png](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication/http-auth-sequence-diagram.png)

**Популярные методы аутентификации**

* Проверка подлинности на основе пароля (**Password-based authentication**) - это простой метод проверки подлинности, требующий ввода пароля для подтверждения личности пользователя.
* Беспарольная аутентификация (**Passwordless authentication**) - это когда пользователь проверяется с помощью одноразового ПИН-а (OTP - One-time pins) или magic link, доставленной на зарегистрированный адрес электронной почты или номер телефона;
* Для двухфакторной аутентификации/многофакторной аутентификации (**2FA/MFA**) требуется более одного уровня безопасности, например дополнительный PIN-код или контрольный вопрос, для идентификации пользователя и предоставления доступа к системе;
* Единый вход (**SSO**) позволяет пользователям получать доступ к нескольким приложениям с одним набором учетных данных;
* Социальная аутентификация (**Social authentication**) проверяет и аутентифицирует пользователей с существующими учетными данными на платформах социальных сетей.
* Биометрия ([**Biometrics**](https://hackernoon.com/biometric-authentication-working-methods-and-use-cases-3z2a377p)) - пользователь предъявляет отпечаток пальца или скан глаза, чтобы получить доступ к системе.

**Популярные методы авторизации**

* Управление доступом на основе ролей (**RBAC - Role-based access controls**) может быть реализовано для управления привилегиями от системы к системе и от пользователя к системе.
* Веб-токен JSON ([**JWT - JSON web token**](https://gist.github.com/zmts/802dc9c3510d79fd40f9dc38a12bccfc)) - это открытый стандарт для безопасной передачи данных между сторонами, а пользователи авторизуются с помощью пары открытый/закрытый ключ.
* **SAML** - это стандартный формат единого входа (SSO), в котором аутентификационная информация передается через XML-документы с цифровой подписью.
* Авторизация [**OpenID**](https://habr.com/ru/company/nixys/blog/566910/) проверяет личность пользователя на основе аутентификации сервера авторизации;
* [**OAuth**](https://betterprogramming.pub/the-complete-guide-to-oauth-2-0-and-openid-connect-protocols-35ebc1cbc11a) позволяет API аутентифицировать и получать доступ к запрошенной системе или ресурсу.

**Аутентификация на основе сессий**

Протокол HTTP не отслеживает состояния, и, если мы аутентифицируем пользователя с помощью имени и пароля, наше приложение не будет знать, тот ли это человек, что и в предыдущем запросе. Нам придётся аутентифицировать снова. При каждом запросе HTTP не знает ничего о том, что происходило до этого, он лишь передаёт запрос. Так что, если вам нужны личные данные, придётся снова логиниться, чтобы приложение знало, что это точно вы. Может сильно раздражать.

Чтобы избавиться от этого неудобства, придумали аутентификацию на основе сессий/кук, с помощью которых реализовали отслеживание состояний (stateful). Это означает, что аутентификационная запись или сессия должны храниться и на сервере, и на клиенте. Сервер должен отслеживать активные сессии в базе данных или памяти, а на фронтенде создаётся кука, в которой хранится идентификатор сессии. Это аутентификация на основе куки, самая распространенный и широко известный метод, используемый уже давно.

Процедура аутентификации на основе сессий:

* Пользователь вводит в браузере своё имя и пароль, после чего клиентское приложение отправляет на сервер запрос.
* Сервер проверяет пользователя, аутентифицирует его, шлёт приложению уникальный пользовательский токен (сохранив его в памяти или базе данных).
* Клиентское приложение сохраняет токены в куках и отправляет их при каждом последующем запросе.
* Сервер получает каждый запрос, требующий аутентификации, с помощью токена аутентифицирует пользователя и возвращает запрошенные данные клиентскому приложению.
* Когда пользователь выходит, клиентское приложение удаляет его токен, поэтому все последующие запросы от этого клиента становятся неаутентифицированными.

![https://hsto.org/r/w1560/webt/a5/cz/ws/a5czwswt6yvdhan0cm193d4liqq.png](https://hsto.org/r/w1560/webt/a5/cz/ws/a5czwswt6yvdhan0cm193d4liqq.png)

У этого метода несколько недостатков:

* При каждой аутентификации пользователя сервер должен создавать у себя запись. Обычно она хранится в памяти, и при большом количестве пользователей есть вероятность слишком высокой нагрузки на сервер.
* Поскольку сессии хранятся в памяти, масштабировать не так просто. Если вы многократно реплицируете сервер, то на все новые серверы придётся реплицировать и все пользовательские сессии. Это усложняет масштабирование. (Я считал, этого можно избежать, если иметь выделенный сервер для управления сессиями, но это сложно реализовать, да и не всегда возможно.)

**Аутентификация на основе токенов**

Аутентификация на основе токенов в последние годы стала очень популярна из-за распространения одностраничных приложений, веб-API и интернета вещей. Чаще всего в качестве токенов используются Json Web Tokens (JWT). Хотя реализации бывают разные, но токены JWT превратились в стандарт де-факто.

При аутентификации на основе токенов состояния не отслеживаются. Мы не будем хранить информацию о пользователе на сервере или в сессии и даже не будем хранить JWT, использованные для клиентов.

Процедура аутентификации на основе токенов:

* Пользователь вводит имя и пароль.
* Сервер проверяет их и возвращает токен (JWT), который может содержать метаданные вроде user\_id, разрешений и т. д.
* Токен хранится на клиентской стороне, чаще всего в локальном хранилище, но может лежать и в хранилище сессий или кук.
* Последующие запросы к серверу обычно содержат этот токен в качестве дополнительного заголовка авторизации в виде Bearer {JWT}. Ещё токен может пересылаться в теле POST-запроса и даже как параметр запроса.
* Сервер расшифровывает JWT, если токен верный, сервер обрабатывает запрос.
* Когда пользователь выходит из системы, токен на клиентской стороне уничтожается, с сервером взаимодействовать не нужно.

![https://hsto.org/r/w1560/webt/mu/rw/kv/murwkv\_rxhbsjxkogdetqbwl-hk.png](https://hsto.org/r/w1560/webt/mu/rw/kv/murwkv\_rxhbsjxkogdetqbwl-hk.png)

У метода есть ряд преимуществ:

* Главное преимущество: поскольку метод никак не оперирует состояниями, серверу не нужно хранить записи с пользовательскими токенами или сессиями. Каждый токен самодостаточен, содержит все необходимые для проверки данные, а также передаёт затребованную пользовательскую информацию. Поэтому токены не усложняют масштабирование.
* В куках вы просто храните ID пользовательских сессий, а JWT позволяет хранить метаданные любого типа, если это корректный JSON.
* При использовании кук бэкенд должен выполнять поиск по традиционной SQL-базе или NoSQL-альтернативе, и обмен данными наверняка длится дольше, чем расшифровка токена. Кроме того, раз вы можете хранить внутри JWT дополнительные данные вроде пользовательских разрешений, то можете сэкономить и дополнительные обращения поисковые запросы на получение и обработку данных.
* Допустим, у вас есть API-ресурс /api/orders, который возвращает последние созданные приложением заказы, но просматривать их могут только пользователи категории админов. Если вы используете куки, то, сделав запрос, вы генерируете одно обращение к базе данных для проверки сессии, ещё одно обращение - для получения пользовательских данных и проверки, относится ли пользователь к админам, и третье обращение - для получения данных.
* А если вы применяете JWT, то можете хранить пользовательскую категорию уже в токене. Когда сервер запросит его и расшифрует, вы можете сделать одно обращение к базе данных, чтобы получить нужные заказы.
* У использования кук на мобильных платформах есть много ограничений и особенностей. А токены сильно проще реализовать на iOS и Android. К тому же токены проще реализовать для приложений и сервисов интернета вещей, в которых не предусмотрено хранение кук.

Благодаря всему этому аутентификация на основе токенов сегодня набирает популярность.

**Беспарольная аутентификация**

Первой реакцией на термин «беспарольная аутентификация» может быть «Как аутентифицировать кого-то без пароля? Разве такое возможно?». В наши головы внедрено убеждение, что пароли - абсолютный источник защиты наших аккаунтов. Но если изучить вопрос глубже, то выяснится, что беспарольная аутентификация может быть не просто безопасной, но и безопаснее традиционного входа по имени и паролю. Возможно, вы даже слышали мнение, что пароли устарели.

Беспарольная аутентификация - это способ конфигурирования процедуры входа и аутентификации пользователей без ввода паролей. Идея такая: вместо ввода почты/имени и пароля пользователи вводят только свою почту. Ваше приложение отправляет на этот адрес одноразовую ссылку, пользователь по ней кликает и автоматически входит на ваш сайт / в приложение. При беспарольной аутентификации приложение считает, что в ваш ящик пришло письмо со ссылкой, если вы написали свой, а не чужой адрес.

Есть похожий метод, при котором вместо одноразовой ссылки по SMS отправляется код или одноразовый пароль. Код или одноразовый пароль тоже можно отправлять по почте.

И ещё один, менее (пока) популярный (и доступный только на устройствах Apple) метод беспарольной аутентификации: использовать Touch ID для аутентификации по отпечаткам пальцев.

Что может пойти не так: если кто-то получит доступ к пользовательским почтам, он получит и доступ к приложениям и сайтам. Но это не ваша головная боль - беспокоиться о безопасности почтовых аккаунтов пользователей. Кроме того, если кто-то получит доступ к чужой почте, то сможет перехватить аккаунты в приложениях с беспарольной аутентификацией, воспользовавшись функцией восстановления пароля. Но мы ничего не можем поделать с почтой наших пользователей. Пойдём дальше.

В чём преимущества: как часто вы пользуетесь ссылкой «забыли пароль» для сброса чертового пароля, который так и не смогли вспомнить после нескольких неудачных попыток входа на сайт / в приложение? Все мы бываем в такой ситуации. Все пароли не упомнишь, особенно если вы заботитесь о безопасности и для каждого сайта делаете отдельный пароль (соблюдая все эти «должен состоять не менее чем из восьми символов, содержать хотя бы одну цифру, строчную букву и специальный символ»). От всего этого вас избавит беспарольная аутентификация. Знаю, вы думаете сейчас: «Я использую менеджер паролей, идиот». Уважаю. Но не забывайте, что подавляющее большинство пользователей не такие техногики, как вы. Это нужно учитывать.

**Единая точка входа (Single Sign On, SSO)**

Обращали внимание, что, когда логинишься в браузере в каком-нибудь Google-сервисе, например Gmail, а потом идёшь на Youtube или иной Google-сервис, там не приходится логиниться? Ты автоматически получаешь доступ ко всем сервисам компании. Впечатляет, верно? Ведь хотя Gmail и Youtube - это сервисы Google, но всё же раздельные продукты. Как они аутентифицируют пользователя во всех продуктах после единственного входа? Этот метод называется единой точкой входа (Single Sign On, SSO).

Реализовать его можно по-разному. Например, использовать центральный сервис для оркестрации единого входа между несколькими клиентами. В случае с Google этот сервис называется Google Accounts. Когда пользователь логинится, Google Accounts создает куку, которая сохраняется за пользователем, когда тот ходит по принадлежащим компании сервисам. Как это работает:

* Пользователь входит в один из сервисов Google.
* Пользователь получает сгенерированную в Google Accounts куку.
* Пользователь идёт в другой продукт Google.
* Пользователь снова перенаправляется в Google Accounts.
* Google Accounts видит, что пользователю уже присвоена кука, и перенаправляет пользователя в запрошенный продукт.

Очень простое описание единой точки входа: пользователь входит один раз и получает доступ ко всем системам без необходимости входить в каждую из них. В этой процедуре используется три сущности, доверяющие другу прямо и косвенно. Пользователь вводит пароль (или аутентифицируется иначе) у поставщика идентификационной информации (identity provider, IDP), чтобы получить доступ к поставщику услуги (service provider (SP). Пользователь доверяет IDP, и SP доверяет IDP, так что SP может доверять пользователю. Выглядит очень просто, но конкретные реализации бывают очень сложными. [Подробнее об этом методе аутентификации](https://auth0.com/blog/what-is-and-how-does-single-sign-on-work/).

**Аутентификация в соцсетях (Social sign-in)** или социальный логин (Social Login)

Вы можете аутентифицировать пользователей по их аккаунтам в соцсетях. Тогда пользователям не придётся регистрироваться отдельно в вашем приложении.

Формально социальный логин - это не отдельный метод аутентификации. Это разновидность единой точки входа с упрощением процесса регистрации/входа пользователя в ваше приложение.

Лучшее из двух миров: пользователи могут войти в ваше приложение одним кликом, если у них есть аккаунт в одной из соцсетей. Им не нужно помнить логины и пароли. Это сильно улучшает опыт использования вашего приложения. Вам не нужно волноваться о безопасности пользовательских данных и думать о проверке адресов почты - они уже проверены соцсетями. Кроме того, в соцсетях уже есть механизмы восстановления пароля.

Как использовать: большинство соцсетей в качестве механизма аутентификации используют авторизацию через OAuth2 (некоторые используют OAuth1, например Twitter). Разберёмся, что такое OAuth. Соцсеть - это сервер ресурсов, ваше приложение - клиент, а пытающийся войти в ваше приложение пользователь - владелец ресурса. Ресурсом называется пользовательский профиль / информация для аутентификации. Когда пользователь хочет войти в ваше приложение, оно перенаправляет пользователя в соцсеть для аутентификации (обычно это всплывающее окно с URL’ом соцсети). После успешной аутентификации пользователь должен дать вашему приложению разрешение на доступ к своему профилю из соцсети. Затем соцсеть возвращает пользователя обратно в ваше приложение, но уже с токеном доступа. В следующий раз приложение возьмёт этот токен и запросит у соцсети информацию из пользовательского профиля. Так работает OAuth (ради простоты я опустил технические подробности).

Для реализации такого механизма вам может понадобиться зарегистрировать свое приложение в разных соцсетях. Вам дадут app\_id и другие ключи для конфигурирования подключения к соцсетям. Также есть несколько популярных библиотек/пакетов (вроде Passport, Laravel Socialite и т. д.), которые помогут упростить процедуру и избавят от излишней возни.

**Двухфакторная аутентификация (2FA)**

Двухфакторная аутентификация (2FA) улучшает безопасность доступа за счет использования двух методов (также называемых факторами) проверки личности пользователя. Это разновидность [многофакторной аутентификации](https://ru.wikipedia.org/wiki/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D1%84%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D0%BD%D0%B0%D1%8F\_%D0%B0%D1%83%D1%82%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F). Наверное, вам не приходило в голову, но в банкоматах вы проходите двухфакторную аутентификацию: на вашей банковской карте должна быть записана правильная информация, и в дополнение к этому вы вводите PIN. Если кто-то украдет вашу карту, то без кода он не сможет ею воспользоваться. (Не факт! - Примеч. пер.) То есть в системе двухфакторной аутентификации пользователь получает доступ только после того, как предоставит несколько отдельных частей информации.

Другой знакомый пример - двухфакторная аутентификация Mail.Ru, Google, Facebook и т. д. Если включён этот метод входа, то сначала вам нужно ввести логин и пароль, а затем одноразовый пароль (код проверки), отправляемый по SMS. Если ваш обычный пароль был скомпрометирован, аккаунт останется защищенным, потому что на втором шаге входа злоумышленник не сможет ввести нужный код проверки.

Вместо одноразового пароля в качестве второго фактора могут использоваться отпечатки пальцев или снимок сетчатки.

При двухфакторной аутентификации пользователь должен предоставить **два из трёх**:

* **То, что вы знаете**: пароль или PIN.
* **То, что у вас есть**: физическое устройство (смартфон) или приложение, генерирующее одноразовые пароли.
* **Часть вас**: биологически уникальное свойство вроде ваших отпечатков пальцев, голоса или снимка сетчатки.

Большинство хакеров охотятся за паролями и PIN-кодами. Гораздо труднее получить доступ к генератору токенов или биологическим свойствам, поэтому сегодня двухфакторка обеспечивает высокую безопасность аккаунтов.

То есть это универсальное решение? [Возможно](https://medium.com/@the\_economist/where-are-the-flaws-in-two-factor-authentication-5f7a468f41a9), [нет](https://www.theverge.com/2017/7/10/15946642/two-factor-authentication-online-security-mess).

И всё же двухфакторка поможет усилить безопасность аутентификации в вашем приложении. Как реализовать? Возможно, стоит не велосипедить, а воспользоваться существующими решениями вроде Auth0 или Duo.

Источники:

* [Идентификация, аутентификация и авторизация - в чем разница?](https://www.kaspersky.ru/blog/identification-authentication-authorization-difference/29123/)
* [HTTP authentication](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication)
* [Authentication and Authorization Defined: What's the Difference?](https://www.loginradius.com/blog/start-with-identity/authentication-vs-authorization-infographic/)
* [Как ты реализуешь аутентификацию, приятель?](https://habr.com/ru/company/vk/blog/343288/)

# Регрессионные виды тестирования (Regression testing)

_Регрессионное тестирование (regression testing): Тестирование уже протестированной программы, проводящееся после модификации для уверенности в том, что процесс модификации не внес или не активизировал ошибки в областях, не подвергавшихся изменениям. Проводится после изменений в коде программного продукта или его окружении. (ISTQB)_

**Регресс** - это противоположность прогресса. Любое ПО по мере прогресса в функционале неизбежно усложняется, увеличиваются взаимосвязи в функциях и т.п., и чтобы убедиться в том, что в существующей системе не начинается регресс, полезно иногда проводить ее полное тестирование. И уж тем более логично перетестировать всё, что можно, если в систему были внесены какие-то существенные изменения. Но этого недостаточно. По-сути, проблема намного серьезнее - мы каждый раз не знаем, что принесет с собой новая функциональность в системе. Нам каждый раз надо предположить/узнать/протестировать новые взаимодействия в системе, а не тестировать только новые функции в изоляции от остальных. Старый функционал с новым если начинают пересекаться - надо заново расчехлять аналитику, выявлять новые ситуации, которые могут возникнуть, писать новые тест-кейсы, которые затрагивают уже не столько функциональные, сколько интеграционные аспекты. Поэтому выяснение "не наступил ли регресс" (внимание, не путать с "не наступила ли регрессия") - постоянная задача, которую также необходимо решать в контексте maintenance testing.

**Регрессионное тестирование** (Regression Testing) - собирательное название для всех видов тестирования программного обеспечения связанных с изменениями, направленных на обнаружение ошибок в уже протестированных участках исходного кода, на проверку того, что новая функциональность не зааффектила (affect) старую. Такие ошибки - когда после внесения изменений в программу перестаёт работать то, что должно было продолжать работать, - называют регрессионными ошибками (regression bugs). Регрессионные тесты должны быть частью релизного цикла (Release Cycle) и учитываться при тестовой оценке (test estimation).

При корректировках программы необходимо гарантировать сохранение качества. Для этого используется регрессионное тестирование - дорогостоящая, но необходимая деятельность в рамках maintenance testing, направленная на перепроверку корректности измененной программы. В соответствии со стандартным определением, регрессионное тестирование - это выборочное тестирование, позволяющее убедиться, что изменения не вызвали нежелательных побочных эффектов, или что измененная система по-прежнему соответствует требованиям. Регрессионное тестирование обычно проводится перед релизом новой версии приложения. Это происходит следующим образом: в течение какого-то времени делаются какие-то фичи и другие задачи, они тестируются по отдельности и сливаются в общую ветку (мастер/девелоп - чаще всего эта ветка называется в зависимости от процессов в проекте). Дальше, когда время подходит к релизу от ветки девелопа создается ветка релиза, из которой собирается релиз-кандидат и на нем уже проводят регресс.

Главной задачей maintenance testing является реализация систематического процесса обработки изменений в коде. После каждой модификации программы необходимо удостовериться, что на функциональность программы не оказал влияния модифицированный код. Если такое влияние обнаружено, говорят о регрессионном дефекте. Для регрессионного тестирования функциональных возможностей, изменение которых не планировалось, используются ранее разработанные тесты. Одна из целей регрессионного тестирования состоит в том, чтобы, в соответствии с используемым критерием покрытия кода (например, критерием покрытия потока операторов или потока данных), гарантировать тот же уровень покрытия, что и при полном повторном тестировании программы. Для этого необходимо запускать тесты, относящиеся к измененным областям кода или функциональным возможностям.

Другая цель регрессионного тестирования состоит в том, чтобы удостовериться, что программа функционирует в соответствии со своей спецификацией, и что изменения не привели к внесению новых ошибок в ранее протестированный код. Эта цель всегда может быть достигнута повторным выполнением всех тестов регрессионного набора, но более перспективно отсеивать тесты, на которых выходные данные модифицированной и старой программы не могут различаться. Важной задачей регрессионного тестирования является также уменьшение стоимости и сокращение времени выполнения тестов.

Можно заключить, что регрессионное тестирование выполняется чтобы минимизировать регрессионные риски. То есть, риски того, что при очередном изменении продукт перестанет выполнять свои функции. С регрессионным тестированием плотно связана другая активность - импакт анализ (Impact Analysis, анализ влияния изменений). Итоговая область регрессии называется Regression Scope / Scope of Regression.

**Классификация регрессионного тестирования**:

* Проверить всё (Retest All): Как следует из названия, все тест-кейсы в наборе тестов повторно выполняются, чтобы гарантировать отсутствие ошибок, возникших из-за изменения кода. Это дорогостоящий метод, поскольку он требует больше времени и ресурсов по сравнению с другими методами;
* Минимизация набора тестов (test suite minimization) стремится уменьшить размер тестового набора за счет устранения избыточных тестовых примеров из тестового набора;
* Задача выбора теста (test case selection) связана с проблемой выбора подмножества тестов, которые будут использоваться для проверки измененных частей программного обеспечения. Для этого требуется выбрать подмножество тестов из предыдущей версии, которые могут обнаруживать неисправности, основываясь на различных стратегиях. Большинство задокументированных методов регрессионного тестирования сосредоточены именно на этой технике. Обычная стратегия состоит в том, чтобы сосредоточить внимание на отождествления модифицированных частей SUT (system under test) и для выбора тестовых случаев, имеющих отношение к ним. Например, техника полного повторного тестирования (retest-all) - один из наивных типов выбора регрессионного теста путем повторного выполнения всех видов тестов от предыдущей версии на новой. Она часто используется в промышленности из-за её простого и быстрого внедрения. Тем не менее, её способность обнаружения неисправностей ограничена. Таким образом, значительный объём работ связан с разработкой эффективных и масштабируемых селективных методов;
* Задача определения приоритетов теста (test case prioritization). Ее цели заключаются в выполнении заказанных тестов на основе какого-либо критерия. Например, на основе истории, базы или требований, которые, как ожидается, приведут к более раннему выявлению неисправностей или помогут максимизировать некоторые другие полезные свойства;
* Гибридный: Гибридный метод представляет собой комбинацию выборочного и приоритезации. Вместо того, чтобы выбирать весь набор тестов, выберите только те тест-кейсы, которые повторно выполняются в зависимости от их приоритета;

**Типы регрессии по Канеру**:

* Регрессия багов (Bug regression) - попытка доказать, что исправленная ошибка на самом деле не исправлена;
* Регрессия старых багов (Old bugs regression) - попытка доказать, что недавнее изменение кода или данных сломало исправление старых ошибок, т.е. старые баги стали снова воспроизводиться;
* Регрессия побочного эффекта (Side effect regression) - попытка доказать, что недавнее изменение кода или данных сломало другие части разрабатываемого приложения;

**Регрессия в Agile**:

В Agile продукт разрабатывается в рамках короткой итерации, называемой спринтом, которая длится 2-4 недели. В Agile существует несколько итераций, поэтому это тестирование играет важную роль, поскольку в итерациях добавляется новая функциональность или изменения кода. Набор регрессионных тестов должен быть подготовлен на начальном этапе и обновляться с каждым спринтом. В Agile проверки регрессии делятся на две категории:

* Регрессия уровня спринта (Sprint Level Regression): выполняется в основном для новых функций или улучшений, внесенных в последний спринт. Тест-кейсы из набора тестов выбираются в соответствии с новыми добавленными функциями или сделанными улучшениями;
* Сквозная регрессия (End to End Regression): включает в себя все тест-кейсы, которые должны быть повторно выполнены для сквозного тестирования всего продукта, охватывая все основные функции;

**Смоук тестирование (Smoke testing)**

_Тест "на дым" (smoke test): Выборка из общего числа запланированных тестовых сценариев, покрывающая основную функциональность компонента или системы. Проводится с целью удостовериться, что базовые функции программы в целом работают корректно, без углубления в детали. Ежедневная сборка и тест "на дым" являются передовыми практическими методами. См. входной тест, тест верификации сборки. (ISTQB)_

_Тест верификации сборки (build verification test): Набор автоматических тестов, валидирующих целостность каждой новой сборки и верифицирующих ее ключевую/базовую функциональность, стабильность и тестируемость. Данный вид тестирования используется там, где присутствует высокая частота сборок (например, проекты с использованием гибких методологий разработки) и выполняется для каждой новой сборки перед передачей ее в тестирования. См. также регрессионное тестирование, тест "на дым". (ISTQB)_

Smoke testing, BVT - Build Verification Testing, BAT - Builds Acceptance Testing, Breath Testing, Shakeout/Shakedown Testing, Intake test, а также в русскоязычных вариантах дымовое, на дым, дымное, тестирование сборки и т.п. - это подмножество регрессионного тестирования, короткий цикл тестов, выполняемый для каждой новой сборки для подтверждения того, что ПО после внесенных изменений стартует и выполняет основные функции без критических и блокирующих дефектов. В случае отсутствия блокеров Smoke testing объявляется пройденным, и команда QA может начинать дальнейшее тестирование полного цикла, в противном случае, сборка объявляется дефектной, что делает дальнейшее тестирование пустой тратой времени и ресурсов. В таком случае сборка возвращается на доработку и исправление. Smoke testing обычно используется для Integration, Acceptance and System Testing.

Если мы говорим про сайт интернет-магазина, то сценарий может быть следующим:

* Сайт открывается
* Можно выбрать случайный товар и добавить его в корзину
* Можно оформить и оплатить заказ

Если мы говорим про мобильное приложение, например, messenger, то:

* Приложение устанавливается и запускается
* Можно авторизоваться
* Можно написать сообщение случайном контакту

Небольшая шпаргалка по степени важности:

* **smoke** - самое важное. Тест-кейсы играют очень важную роль на этом уровне тестирования, поэтому предел метрик (metric limit) часто соответствует 100% или примерно 100%;
* **critical path** - повседневное. Тесты критического пути запускаются для проверки функциональности, используемой типичными пользователями в их повседневной деятельности. Есть много пользователей, которые обычно используют определенную часть функциональности приложения, которую необходимо проверить, как только smoke этап будет успешно завершен. Здесь лимит метрик немного ниже, чем у smoke, и соответствует 70-80-90% в зависимости от цели проекта;
* **extended** - все. Выполняется для изучения всей функциональности, указанной в требованиях. Проверяется даже функциональность с низким приоритетом. При этом в этом тестировании нужно понимать, какой функционал наиболее ценный, а какой менее важный. При условии, что у вас достаточно времени или других ресурсов, тесты на этом уровне можно использовать для требований с низким приоритетом;

Примечание. В русском языке термин ошибочно переводят как проверка дыма, корректнее уж говорить “на дым”. [История термина:](https://ru.wikipedia.org/wiki/Smoke\_test) Первое свое применение этот термин получил у печников, которые, собрав печь, закрывали все заглушки, затапливали ее и смотрели, чтобы дым шел только из положенных мест. Повторное «рождение» термина произошло в радиоэлектронике. Первое включение нового радиоэлектронного устройства, пришедшего из производства, совершается на очень короткое время (меньше секунды). Затем инженер руками ощупывает все микросхемы на предмет перегрева. Сильно нагревшаяся за эту секунду микросхема может свидетельствовать о грубой ошибке в схеме. Если первое включение не выявило перегрева, то прибор включается снова на большее время. Проверка повторяется. И так далее несколько раз. Выражение «smoke-test» используется инженерами в шуточном смысле, так как появления дыма, а значит и порчи частей устройства, стараются избежать.

**Санити тестирование (Sanity testing)**

_Тест работоспособности (sanity test): См. тест "на дым". (ISTQB)_

Другие источники:

Sanity testing также является подмножеством регрессионного тестирования и выполняется до или вместо полной регрессии, но после smoke. Эти два подвида похожи, но в целом Sanity используется на более стабильных билдах для определения работоспособности определенной части приложения после внесения изменений.

Примечание. Санитарным это тестирование в русскоязычной среде назвалось по совершенно непонятным причинам, но гуглится только так. На самом же деле дословно переводится как тестирование на вменяемость / разумность / работоспособность / согласованность или по версии ISTQB “Тест работоспособности”.

**Подтверждающее, повторное тестирование (**[**confirmation testing**](https://www.softwaretestingmaterial.com/confirmation-testing/)**,** [**re-testing**](https://www.softwaretestingmaterial.com/retesting/)**)**

_Подтверждающее тестирование (confirmation testing): Тестирование, при котором выполняются тестовые сценарии, которые были не пройдены при последнем запуске, с целью подтвердить успешность исправлений. (ISTQB)_

Повторное тестирование - это тип тестирования, выполняемый в новой сборке по проваленному на старой сборке тест-кейсу с тем же окружением и данными, для проверки того, что этот дефект теперь устранен. Ре-тест выполняется перед sanity-тестированием, приоритет ре-теста выше регрессионных проверок, поэтому оно должно выполняться перед ними.

**Тестирование N+1 (N+1 testing)**

Вариант регрессионного тестирования представлен как N+1. В этом методе тестирование выполняется в несколько циклов, в которых ошибки, обнаруженные в тестовом цикле «N», устраняются и повторно тестируются в тестовом цикле N + 1. Цикл повторяется, пока не будет найдено ни одной ошибки.

**Разница между повторным и регрессионным тестированием:**

* Регрессионное тестирование проводится для подтверждения того, что недавнее изменение программы или кода не оказало неблагоприятного воздействия на существующие функции. Повторное тестирование проводится для подтверждения того, что тест-кейсы, которые не прошли, проходят после устранения дефектов;
* Цель регрессионного тестирования подтвердить, что новые изменения кода не должны иметь побочных эффектов для существующих функций. Повторное тестирование проводится на основе исправлений дефектов.;
* Проверка дефектов не является частью регрессионного тестирования. Проверка дефекта является частью повторного тестирования;
* В зависимости от проекта и наличия ресурсов, регрессионное тестирование может проводиться параллельно с повторным тестированием. Приоритет повторного тестирования выше, чем регрессионное тестирование, поэтому оно проводится перед регрессионным тестированием;
* Регрессионное тестирование называется общим (generic) тестированием. Повторное тестирование - это плановое (planned) тестирование;
* Регрессионное тестирование проводится для пройденных Test case. Повторное тестирование проводится только для неудачных тестов;
* Регрессионное тестирование проверяет наличие неожиданных побочных эффектов. Повторное тестирование гарантирует, что первоначальная ошибка была исправлена;
* Test case для регрессионного тестирования могут быть получены из функциональной спецификации, user tutorials and manuals, а также defect reports в отношении исправленных проблем. Test case для повторного тестирования не могут быть получены до начала тестирования;

**Может ли быть ситуация, когда регрессия проводится не после изменений в коде?**

Да, в ситуациях с внешними факторами: изменения в БД, версии ОС и т.п.

Источники:

* [Maintenance, Regression testing and Re-testing](https://software-testing.ru/forum/index.php?/topic/31783-maintenance-regression-testing-and-re-testing/)
* [Регрессионное тестирование](https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D1%80%D0%B5%D1%81%D1%81%D0%B8%D0%BE%D0%BD%D0%BD%D0%BE%D0%B5\_%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
* [Тестировщики нужны - пост “Регресс для самых маленьких”](https://t.me/qa\_chillout/92)
* [QA Outsourcing: Smoke Testing, Critical Path Testing, Extended Testing](https://testing-companies.com/qa-outsourcing-smoke-testing-critical-path-testing-extended-testing/)
* [What Is Regression Testing? Definition, Tools, Method, And Example](https://www.softwaretestinghelp.com/regression-testing-tools-and-methods/)
* [В чём разница Smoke, Sanity, Regression, Re-test и как их различать?](https://habr.com/ru/post/358142/)
* [Difference Between Retesting and Regression Testing](https://www.guru99.com/re-testing-vs-regression-testing.html)
* [Top 150 Software Testing Interview Questions and Answers for Freshers and Experienced](https://www.guru99.com/software-testing-interview-questions.html)

Дополнительный материал:

* [ГОСТ Р 56920-2016/ISO/IEC/IEEE 29119-1:2013](https://docs.cntd.ru/document/1200134996) “D.6 Подпроцесс регрессионного тестирования”, “D.7 Подпроцесс повторного тестирования”
* [Лекция 11: Регрессионное тестирование: цели и задачи, условия применения, классификация тестов и методов отбора](https://intuit.ru/studies/courses/48/48/lecture/1444?page=1)
* [Black Box Software Testing PART 11 - REGRESSION TESTING by Cem Kaner](http://testingeducation.org/k04/bbst11\_2004.pdf) + [2005 year version](https://present5.com/black-box-software-testing-spring-2005-regression-testing/)
* [Епифанов Н. А. - Методы реализации регрессионного тестирования по расширенным тестовым наборам](https://elib.spbstu.ru/dl/577.pdf/view)
* [Anti-Regression Approaches: Impact Analysis and Regression Testing Compared and Combined - Part I: Introduction and Impact Analysis](https://gerrardconsulting.com/blog/2010/04/anti-regression-approaches-impact-analysis-and-regression-testing-compared-and-combined-part-i-introduction-and-impact-analysis/)
* [Anti-Regression Approaches - Part II: Regression Prevention and Detection Using Static Techniques](https://gerrardconsulting.com/blog/category/impact\_analysis/)
* [Как сохранить нервы тестировщика или ускорить регресс с 8 до 2 часов](https://habr.com/ru/company/vivid\_money/blog/559024/#habracut)
* [Регрессионное тестирование или Regression Testing](https://intellect.icu/regressionnoe-testirovanie-ili-regression-testing-6093)
* [QA Outsourcing: Smoke Testing, Critical Path Testing, Extended Testing](https://testing-companies.com/qa-outsourcing-smoke-testing-critical-path-testing-extended-testing/)
* [Антирегрессионное тестирование - минимизируйте затраты](https://habr.com/ru/company/typeable/blog/583062/)
* [Способы сокращения регрессионного тестирования](https://www.youtube.com/watch?v=pEJfP52GWTg)
* [Курс Тестирование ПО. Занятие 26. Регрессионное тестирование (Regression Testing)](https://www.youtube.com/watch?v=1f3yfUnji8o)
* [История о бесконечном регрессионном тестировании](https://habr.com/ru/company/icl\_services/blog/668742/)
